<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo升级大法(3)-给你的点击比个心]]></title>
    <url>%2F2018%2F04%2F26%2FHexo%2FHexo%E5%8D%87%E7%BA%A7%E5%A4%A7%E6%B3%953%2F</url>
    <content type="text"><![CDATA[鼠标心形点击特效文章转自：https://mapan.tech/posts/76c9.html 在\Blog\themes\next\source\js\src\目录下新建love.js,代码如下 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在Blog\themes\next\layout\_layout.swig文件的最下方，&lt;/body&gt;前面添加&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo升级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo升级大法(2)-评论]]></title>
    <url>%2F2018%2F04%2F26%2FHexo%2FHexo%E5%8D%87%E7%BA%A7%E5%A4%A7%E6%B3%952%2F</url>
    <content type="text"><![CDATA[Gitalk非原创，自己记录下 本文转自：https://asdfv1929.github.io/2018/01/20/gitalk/ Gitalk 是一个基于 Github Issue 和 Preact 开发的评论插件。 注册Register Application在GitHub上注册新应用，链接：https://github.com/settings/applications/new 参数说明：Application name： # 应用名称，随意Homepage URL： # 网站URL，如https://hermeswu.github.ioApplication description: # 描述，随意Authorization callback URL：# 网站URL，https://hermeswu.github.io 点击注册后，页面跳转如下，其中Client ID和Client Secret在后面的配置中需要用到，到时复制粘贴即可： 配置文件gitalk.swig新建/layout/_third-party/comments/gitalk.swig文件，并添加内容： 12345678910111213141516&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;, clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;, admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;], id: &lt;%= page.date %&gt;, distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos; &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&#123;% endif %&#125; comments.swig修改/layout/_partials/comments.swig，添加内容如下，与前面的elseif同一级别上： 12&#123;% elseif theme.gitalk.enable %&#125; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; index.swig修改layout/_third-party/comments/index.swig，在最后一行添加内容 1&#123;% include &apos;gitalk.swig&apos; %&#125; gitalk.styl新建/source/css/_common/components/third-party/gitalk.styl文件，添加内容： 1234.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em; third-party.styl修改/source/css/_common/components/third-party/third-party.styl，在最后一行上添加内容，引入样式： 1@import &quot;gitalk&quot;; _config.yml在主题配置文件next/_config.yml中添加如下内容： 12345678gitalk: enable: true githubID: github帐号 # 例：HermesWu repo: 仓库名称 # 例：HermesWu.github.io ClientID: Client ID ClientSecret: Client Secret adminUser: github帐号 #指定可初始化评论账户 distractionFreeMode: true 以上就是NexT中添加gitalk评论的配置，博客上传到GitHub上后，打开页面进入某一博客内容下，就可看到评论处。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo升级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo升级大法（1）]]></title>
    <url>%2F2018%2F04%2F25%2FHexo%2FHexo%E5%8D%87%E7%BA%A7%E5%A4%A7%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Hexo 升级之路 一些不可抗的地球引力原因，打算把个人电脑的一部分MD文件放到博客上，毕竟，这年头，小白就要多学手艺，多一份找工作的机会不是。由于个人的审美以及目的不同，我选择了next这个大名鼎鼎的主题。我的Hexo博客，自打建立之初到现在荒废已久，所以，今天要折腾下，升级的问题。走起吧~ 第一步，把冰箱门打开，不对，是升级Hexo很简单(但是我不goole下，我是不知道滴)，进入blog的目录，检查更新： 12345678npm outdatedPackage Current Wanted Latest Locationhexo-deployer-git 0.2.0 0.2.0 0.3.1 hexo-sitehexo-generator-search 1.0.4 1.0.4 2.2.1 hexo-sitehexo-generator-seo-friendly-sitemap 0.0.19 0.0.19 0.0.21 hexo-sitehexo-renderer-ejs 0.2.0 0.2.0 0.3.1 hexo-sitehexo-renderer-marked 0.2.11 0.2.11 0.3.2 hexo-sitehexo-server 0.2.2 0.2.2 0.3.1 hexo-site 根据需要，简单修改一下package.json文件： 1234567891011121314151617181920&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;3.7.1&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.7.1&quot;, &quot;hexo-deployer-git&quot;: &quot;^0.3.1&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, &quot;hexo-server&quot;: &quot;^0.3.1&quot; &#125;&#125; 把 Hexo 的版本号修改为3.7.1，其他的也根据情况更新一下。 齐活，npm更新一下 npm install --save 检查下Hexo 123456789101112131415161718hexo versionhexo: 3.7.1hexo-cli: 1.1.0os: Darwin 16.7.0 darwin x64http_parser: 2.7.0node: 8.9.1v8: 6.1.534.47uv: 1.15.0zlib: 1.2.11ares: 1.10.1-DEVmodules: 57nghttp2: 1.25.0openssl: 1.0.2micu: 59.1unicode: 9.0cldr: 31.0.1tz: 2017b 第二步，把大象装进冰箱，不对，是设置主题下载主题 在终端切换到hexo 根目录. 在hexo目录下一定有 node_modules, source, themes 和其他文件夹: 从 github 上获取主题 。这里有几种方式来获取主题: 在大多数情况下 稳定。 推荐用户下载这个。 12 $ mkdir themes/next$ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d &apos;&quot;&apos; -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1 您必须定义版本。从标签列表里选择版本替换v5.1.2。 12 $ mkdir themes/next$ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball/v5.1.2 | tar -zxv -C themes/next --strip-components=1 使用克隆命令，你将得到整个存储库。而且在任何时候你都可以切换到任何标签发布版本。 获取标签列表： 12345678910$ git clone https://github.com/iissnan/hexo-theme-next themes/next$ cd themes/next$ git tag -l…v5.0.0v5.0.1v5.1.0v5.1.1v5.1.2 例如, 你想要切换到v5.1.0 标签发布版本. 输入以下命令: 1234$ git checkout tags/v5.1.0Note: checking out &apos;tags/v5.1.0&apos;.…HEAD now on 1f72f68... CSS: Remove global list-style setting of ul 如果你想切换回 master 分支的话, 输入这个命令: `$ git checkout master` 在 hexo 根目录下 的配置文件_config.yml里设置主题: theme: next 修改语言在站点配置文件_config.yml中可以将语言切换成中文 1234567891011121314language: en# language: zh-Hans# language: zh-hk# language: zh-tw# language: ru# language: fr-FR# language: de# language: ja# language: id# language: pt# language: pt-BR# language: ko# language: it# language: nl-NL 我勒个去，这么简单点事，搞到半夜1点了，真是智商低，睡吧睡吧，猴年马月在补上]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo升级</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS里的类型]]></title>
    <url>%2F2018%2F04%2F25%2FJavaScript%2FJS%E9%87%8C%E7%9A%84%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JS里的类型任意类型转字符串 String(x） x.toString() x + ‘’ 任意类型转数字 Number(x) parseInt(x, 10)MDN相关资料 parseFloat(x)MDN相关资料 x - 0 +x 任意类型转布尔 Boolean(x) !!x 内存图 你买一个 8G 的内存条 操作系统开机即占用 512MB Chrome 打开即占用 1G 内存 Chrome给每个网页分配一定数量的内存 这些内存要分给页面渲染器、网络模块、浏览器外壳和 JS 引擎（V8引擎） JS 引擎将内存分为代码区和数据区 我们只研究数据区 数据区分为 Stack（栈内存） 和 Heap（堆内存） 简单类型的数据直接存在 Stack 里 复杂类型的数据是把 Heap 地址存在 Stack 里 some面试题1234567891011121314151617181920212223242526javascriptvar a = 1var b = ab = 2请问 a 显示是几？ javascriptvar a = &#123;name: &apos;a&apos;&#125;var b = ab = &#123;name: &apos;b&apos;&#125;请问现在 a.name 是多少？javascriptvar a = &#123;name: &apos;a&apos;&#125;var b = ab.name = &apos;b&apos;请问现在 a.name 是多少？javascriptvar a = &#123;name: &apos;a&apos;&#125;var b = ab = null请问现在 a 是什么？ 深复制12345var a = 1var b = ab = 2 //这个时候改变 ba 完全不受 b 的影响那么我们就说这是一个深复制 对于简单类型的数据来说，赋值就是深拷贝。对于复杂类型的数据（对象）来说，才要区分浅拷贝和深拷贝。 这是一个浅拷贝的例子 1234var a = &#123;name: &apos;frank&apos;&#125;var b = ab.name = &apos;b&apos;a.name === &apos;b&apos; // true 因为我们对 b 操作后，a 也变了 什么是深拷贝了，就是对 Heap 内存进行完全的拷贝。 1234var a = &#123;name: &apos;frank&apos;&#125;var b = deepClone(a) // deepClone 还不知道怎么实现b.name = &apos;b&apos;a.name === &apos;a&apos; // true]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas基础API]]></title>
    <url>%2F2018%2F04%2F25%2F%E5%89%8D%E7%AB%AF%2FCanvas%E5%9F%BA%E7%A1%80API%2F</url>
    <content type="text"><![CDATA[canvasCanvas MDN文档： https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API Canvas 的默认大小为300像素×150像素（宽×高，像素的单位是px）。但是，可以使用HTML的高度和宽度属性来自定义Canvas 的尺寸。为了在 Canvas 上绘制图形，我们使用一个JavaScript上下文对象，它能动态创建图像（ creates graphics on the fly）。&lt;canvas id=&quot;tutorial&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt;&lt;canvas&gt; 看起来和 &lt;img&gt; 元素很相像，唯一的不同就是它并没有 src 和 alt 属性。实际上，&lt;canvas&gt; 标签只有两个属性—— width和height。这些都是可选的，并且同样利用 DOM properties 来设置。当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。该元素可以使用CSS来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果CSS的尺寸与初始画布的比例不一致，它会出现扭曲。注意: 如果你绘制出来的图像是扭曲的, 尝试用width和height属性为&lt;canvas&gt;明确规定宽高，而不是使用CSS。canvas起初是空白的。为了展示，首先脚本需要找到渲染上下文，然后在它的上面绘制。&lt;canvas&gt; 元素有一个叫做 getContext() 的方法，这个方法是用来获得渲染上下文和它的绘画功能。getContext()只有一个参数，上下文的格式。对于2D图像而言，如本教程，你可以使用 CanvasRenderingContext2D代码的第一行通过使用 document.getElementById()方法来为 &lt;canvas&gt; 元素得到DOM对象。一旦有了元素对象，你可以通过使用它的getContext() 方法来访问绘画上下文 检查支持性替换内容是用于在不支持 &lt;canvas&gt; 标签的浏览器中展示的。通过简单的测试getContext()方法的存在，脚本可以检查编程支持性。上面的代码片段现在变成了这个样子： 123456789var canvas = document.getElementById(&apos;tutorial&apos;);if (canvas.getContext)&#123; var ctx = canvas.getContext(&apos;2d&apos;); // drawing code here&#125; else &#123; // canvas-unsupported code here&#125; 模板骨架12345678910111213141516171819&lt;html&gt; &lt;head&gt; &lt;title&gt;Canvas tutorial&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function draw()&#123; var canvas = document.getElementById(&apos;tutorial&apos;); if (canvas.getContext)&#123; var ctx = canvas.getContext(&apos;2d&apos;); &#125; &#125; &lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; canvas &#123; border: 1px solid black; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body onload=&quot;draw();&quot;&gt; &lt;canvas id=&quot;tutorial&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt; 上面的脚本中包含一个叫做draw()的函数，当页面加载结束的时候就会执行这个函数。通过使用在文档上加载事件来完成。只要页面加载结束，这个函数，或者像是这个的，同样可以使用 window.setTimeout()， window.setInterval()，或者其他任何事件处理程序来调用。 一个简单的例子12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;script type=&quot;application/javascript&quot;&gt; function draw() &#123; var canvas = document.getElementById(&quot;canvas&quot;); if (canvas.getContext) &#123; var ctx = canvas.getContext(&quot;2d&quot;); ctx.fillStyle = &quot;rgb(200,0,0)&quot;; ctx.fillRect (10, 10, 55, 50); ctx.fillStyle = &quot;rgba(0, 0, 200, 0.5)&quot;; ctx.fillRect (30, 30, 55, 50); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;draw();&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt; 绘制图形所以图中蓝色方形左上角的坐标为距离左边（X轴）x像素，距离上边（Y轴）y像素（坐标为（x,y））。 矩形不同于SVG，HTML中的元素canvas只支持一种原生的图形绘制：矩形。所有其他的图形的绘制都至少需要生成一条路径。不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能。 首先，我们回到矩形的绘制中。canvas提供了三种方法绘制矩形： fillRect(x, y, width, height)绘制一个填充的矩形 strokeRect(x, y, width, height)绘制一个矩形的边框 clearRect(x, y, width, height)清除指定矩形区域，让清除部分完全透明。 上面提供的方法之中每一个都包含了相同的参数。x与y指定了在canvas画布上所绘制的矩形的左上角（相对于原点）的坐标。width和height设置矩形的尺寸。 1234567891011function draw() &#123; var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext) &#123; var ctx = canvas.getContext(&apos;2d&apos;); ctx.fillRect(25,25,100,100); ctx.clearRect(45,45,60,60); ctx.strokeRect(50,50,50,50); &#125;&#125; 绘制路径图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。使用路径绘制图形需要一些额外的步骤。 首先，你需要创建路径起始点。 然后你使用画图命令去画出路径。 之后你把路径封闭。 一旦路径生成，你就能通过描边或填充路径区域来渲染图形 beginPath()新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。 closePath()闭合路径之后图形绘制命令又重新指向到上下文中。 stroke()通过线条来绘制图形轮廓。 fill()通过填充路径的内容区域生成实心的图形。 生成路径的第一步叫做beginPath()。本质上，路径是由很多子路径构成，这些子路径都是在一个列表中，所有的子路径（线、弧形、等等）构成图形。而每次这个方法调用之后，列表清空重置，然后我们就可以重新绘制新的图形。 第二步就是调用函数指定绘制路径，本文稍后我们就能看到了。 第三，就是闭合路径closePath(),不是必需的。这个方法会通过绘制一条从当前点到开始点的直线来闭合图形。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做。 注意：当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合。 绘制一个三角形123456789101112function draw() &#123; var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext)&#123; var ctx = canvas.getContext(&apos;2d&apos;); ctx.beginPath(); ctx.moveTo(75,50); ctx.lineTo(100,75); ctx.lineTo(100,25); ctx.fill(); &#125;&#125; 移动笔触一个非常有用的函数，而这个函数实际上并不能画出任何东西，也是上面所描述的路径列表的一部分，这个函数就是moveTo()。或者你可以想象一下在纸上作业，一支钢笔或者铅笔的笔尖从一个点到另一个点的移动过程。 moveTo(x, y)将笔触移动到指定的坐标x以及y上。 当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点。我们也能够使用moveTo()绘制一些不连续的路径。看一下下面的笑脸例子。我将用到moveTo()方法（红线处）的地方标记了。 12345678910111213141516function draw() &#123; var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext)&#123; var ctx = canvas.getContext(&apos;2d&apos;); ctx.beginPath(); ctx.arc(75,75,50,0,Math.PI*2,true); // 绘制 ctx.moveTo(110,75); ctx.arc(75,75,35,0,Math.PI,false); // 口(顺时针) ctx.moveTo(65,65); ctx.arc(60,65,5,0,Math.PI*2,true); // 左眼 ctx.moveTo(95,65); ctx.arc(90,65,5,0,Math.PI*2,true); // 右眼 ctx.stroke(); &#125;&#125; 绘制线绘制直线，需要用到的方法lineTo()。 lineTo(x, y)绘制一条从当前位置到指定x以及y位置的直线。 该方法有两个参数：x以及y ，代表坐标系中直线结束的点。开始点和之前的绘制路径有关，之前路径的结束点就是接下来的开始点，等等。。。开始点也可以通过moveTo()函数改变。 下面的例子绘制两个三角形，一个是填充的，另一个是描边的。 123456789101112131415161718192021function draw() &#123; var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext)&#123; var ctx = canvas.getContext(&apos;2d&apos;); // 填充三角形 ctx.beginPath(); ctx.moveTo(25,25); ctx.lineTo(105,25); ctx.lineTo(25,105); ctx.fill(); // 描边三角形 ctx.beginPath(); ctx.moveTo(125,125); ctx.lineTo(125,45); ctx.lineTo(45,125); ctx.closePath(); ctx.stroke(); &#125;&#125; 你会注意到填充与描边三角形步骤有所不同。正如上面所提到的，因为路径使用填充（filled）时，路径自动闭合，使用描边（stroked）则不会闭合路径。如果没有添加闭合路径closePath()到描述三角形函数中，则只绘制了两条线段，并不是一个完整的三角形。 绘制圆弧绘制圆弧或者圆，我们使用arc()方法。当然可以使用arcTo()，不过这个的实现并不是那么的可靠，所以我们这里不作介绍。 arc(x, y, radius, startAngle, endAngle, anticlockwise)画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。 arcTo(x1, y1, x2, y2, radius)根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。 这里详细介绍一下arc方法，该方法有六个参数：x,y为绘制圆弧所在圆上的圆心坐标。radius为半径。startAngle以及endAngle参数用弧度定义了开始以及结束的弧度。这些都是以x轴为基准。参数anticlockwise为一个布尔值。为true时，是逆时针方向，否则顺时针方向。 注意：arc()函数中的角度单位是弧度，不是度数。角度与弧度的js表达式:radians=(Math.PI/180)*degrees。 下面的例子比上面的要复杂一下，下面绘制了12个不同的角度以及填充的圆弧。 下面两个for循环，生成圆弧的行列（x,y）坐标。每一段圆弧的开始都调用beginPath()。代码中，每个圆弧的参数都是可变的，实际生活中，我们并不需要这样做。 x,y坐标是可变的。半径（radius）和开始角度（startAngle）都是固定的。结束角度（endAngle）在第一列开始时是180度（半圆）然后每列增加90度。最后一列形成一个完整的圆。 clockwise语句作用于第一、三行是顺时针的圆弧，anticlockwise作用于二、四行为逆时针圆弧。if语句让一、二行描边圆弧，下面两行填充路径。 注意: 这个示例所需的画布大小略大于本页面的其他例子: 150 x 200 像素。 二次贝塞尔曲线及三次贝塞尔曲线下一个十分有用的路径类型就是贝塞尔曲线。二次及三次贝塞尔曲线都十分有用，一般用来绘制复杂有规律的图形。 quadraticCurveTo(cp1x, cp1y, x, y)绘制二次贝塞尔曲线，cp1x,cp1y为一个控制点，x,y为结束点。 bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)绘制三次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。 右边的图能够很好的描述两者的关系，二次贝塞尔曲线有一个开始点（蓝色）、一个结束点（蓝色）以及一个控制点（红色），而三次贝塞尔曲线有两个控制点 参数x、y在这两个方法中都是结束点坐标。cp1x,cp1y为坐标中的第一个控制点，cp2x,cp2y为坐标中的第二个控制点。 二次贝塞尔曲线这个例子使用多个贝塞尔曲线来渲染对话气泡。 1234567891011121314151617function draw() &#123; var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext) &#123; var ctx = canvas.getContext(&apos;2d&apos;); // 二次贝塞尔曲线 ctx.beginPath(); ctx.moveTo(75,25); ctx.quadraticCurveTo(25,25,25,62.5); ctx.quadraticCurveTo(25,100,50,100); ctx.quadraticCurveTo(50,120,30,125); ctx.quadraticCurveTo(60,120,65,100); ctx.quadraticCurveTo(125,100,125,62.5); ctx.quadraticCurveTo(125,25,75,25); ctx.stroke(); &#125;&#125; 三次贝赛尔曲线这个例子使用贝塞尔曲线绘制心形。 1234567891011121314151617function draw() &#123; var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext)&#123; var ctx = canvas.getContext(&apos;2d&apos;); //三次贝塞尔曲线 ctx.beginPath(); ctx.moveTo(75,40); ctx.bezierCurveTo(75,37,70,25,50,25); ctx.bezierCurveTo(20,25,20,62.5,20,62.5); ctx.bezierCurveTo(20,80,40,102,75,120); ctx.bezierCurveTo(110,102,130,80,130,62.5); ctx.bezierCurveTo(130,62.5,130,25,100,25); ctx.bezierCurveTo(85,25,75,37,75,40); ctx.fill(); &#125;&#125; 矩形直接在画布上绘制矩形的三个额外方法，正如我们开始所见的Drawing rectangles，同样，也有rect()方法，将一个矩形路径增加到当前路径上。 rect(x, y, width, height)绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。当该方法执行的时候，moveTo()方法自动设置坐标参数（0,0）。也就是说，当前笔触自动重置回默认坐标 组合使用目前为止，每一个例子中的每个图形都只用到一种类型的路径。然而，绘制一个图形并没有限制使用数量以及类型。所以在最后的一个例子里，让我们组合使用所有的路径函数来重现一组著名的游戏人物。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function draw() &#123; var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext)&#123; var ctx = canvas.getContext(&apos;2d&apos;); roundedRect(ctx,12,12,150,150,15); roundedRect(ctx,19,19,150,150,9); roundedRect(ctx,53,53,49,33,10); roundedRect(ctx,53,119,49,16,6); roundedRect(ctx,135,53,49,33,10); roundedRect(ctx,135,119,25,49,10); ctx.beginPath(); ctx.arc(37,37,13,Math.PI/7,-Math.PI/7,false); ctx.lineTo(31,37); ctx.fill(); for(var i=0;i&lt;8;i++)&#123; ctx.fillRect(51+i*16,35,4,4); &#125; for(i=0;i&lt;6;i++)&#123; ctx.fillRect(115,51+i*16,4,4); &#125; for(i=0;i&lt;8;i++)&#123; ctx.fillRect(51+i*16,99,4,4); &#125; ctx.beginPath(); ctx.moveTo(83,116); ctx.lineTo(83,102); ctx.bezierCurveTo(83,94,89,88,97,88); ctx.bezierCurveTo(105,88,111,94,111,102); ctx.lineTo(111,116); ctx.lineTo(106.333,111.333); ctx.lineTo(101.666,116); ctx.lineTo(97,111.333); ctx.lineTo(92.333,116); ctx.lineTo(87.666,111.333); ctx.lineTo(83,116); ctx.fill(); ctx.fillStyle = &quot;white&quot;; ctx.beginPath(); ctx.moveTo(91,96); ctx.bezierCurveTo(88,96,87,99,87,101); ctx.bezierCurveTo(87,103,88,106,91,106); ctx.bezierCurveTo(94,106,95,103,95,101); ctx.bezierCurveTo(95,99,94,96,91,96); ctx.moveTo(103,96); ctx.bezierCurveTo(100,96,99,99,99,101); ctx.bezierCurveTo(99,103,100,106,103,106); ctx.bezierCurveTo(106,106,107,103,107,101); ctx.bezierCurveTo(107,99,106,96,103,96); ctx.fill(); ctx.fillStyle = &quot;black&quot;; ctx.beginPath(); ctx.arc(101,102,2,0,Math.PI*2,true); ctx.fill(); ctx.beginPath(); ctx.arc(89,102,2,0,Math.PI*2,true); ctx.fill(); &#125;&#125;// 封装的一个用于绘制圆角矩形的函数.function roundedRect(ctx,x,y,width,height,radius)&#123; ctx.beginPath(); ctx.moveTo(x,y+radius); ctx.lineTo(x,y+height-radius); ctx.quadraticCurveTo(x,y+height,x+radius,y+height); ctx.lineTo(x+width-radius,y+height); ctx.quadraticCurveTo(x+width,y+height,x+width,y+height-radius); ctx.lineTo(x+width,y+radius); ctx.quadraticCurveTo(x+width,y,x+width-radius,y); ctx.lineTo(x+radius,y); ctx.quadraticCurveTo(x,y,x,y+radius); ctx.stroke();&#125; 我们不会很详细地讲解上面的代码，因为事实上这很容易理解。重要的一点是绘制上下文中使用到了fillStyle属性，以及封装函数（例子中的roundedRect()）。使用封装函数对于减少代码量以及复杂度十分有用。 在稍后的课程里，我们会回头再看看fillStyle样式的更多细节。这章节中，我们所做的关于fillStyle样式仅是改变填充颜色，由默认的黑色到白色，然后又是黑色。 Path2D正如我们在前面例子中看到的，你可以使用一系列的路径和绘画命令来把对象“画”在画布上。为了简化代码和提高性能，Path2D对象已可以在较新版本的浏览器中使用，用来缓存或记录绘画命令，这样你将能快速地回顾路径。 Path2D()Path2D()会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）。 123new Path2D(); // 空的Path对象new Path2D(path); // 克隆Path对象new Path2D(d); // 从SVG建立Path对象 所有的路径方法比如moveTo, rect, arc或quadraticCurveTo等，如我们前面见过的，都可以在Path2D中使用。 Path2D API 添加了 addPath作为将path结合起来的方法。当你想要从几个元素中来创建对象时，这将会很实用。比如： Path2D.addPath(path [, transform])​添加了一条路径到当前路径（可能添加了一个变换矩阵）。 Path2D示例在这个例子中，我们创造了一个矩形和一个圆。它们都被存为Path2D对象，后面再派上用场。随着新的Path2D API产生，几种方法也相应地被更新来使用Path2D对象而不是当前路径。在这里，带路径参数的stroke和fill可以把对象画在画布上。 12345678910111213141516function draw() &#123; var canvas = document.getElementById(&apos;canvas&apos;); if (canvas.getContext)&#123; var ctx = canvas.getContext(&apos;2d&apos;); var rectangle = new Path2D(); rectangle.rect(10, 10, 50, 50); var circle = new Path2D(); circle.moveTo(125, 35); circle.arc(100, 35, 25, 0, 2 * Math.PI); ctx.stroke(rectangle); ctx.fill(circle); &#125;&#125; 123456var canvas = document.getElementById(&apos;canvas&apos;)var ctx = canvas.getContext(&apos;2d&apos;)ctx.fillStyle = &apos;green&apos;ctx.fillRect(10, 10, 100, 100)ctx.fillRect(0, 0, canvas.width, canvas.height)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-简单了解一下]]></title>
    <url>%2F2018%2F04%2F25%2F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法伪代码流程图从正整数组 a 中找出最小的数字，打印出来 123456789101112131415161718a &lt;- &#123; &apos;0&apos;: 23 &apos;1&apos;: 43 &apos;2&apos;: 239 &apos;3&apos;: 1321 &apos;4&apos;: 90 &apos;length&apos;: 5&#125;min &lt;- a[&apos;0&apos;]index &lt;- 1while index &lt; a[&apos;length&apos;] if a[index] &lt; min min &lt;- a[index] end index &lt;- index + 1endprint min 相关链接 排序算法列表 https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#排序算法列表 冒泡排序 http://bubkoo.com/2014/01/12/sort-algorithm/bubble-sort/ 插入排序 http://bubkoo.com/2014/01/14/sort-algorithm/insertion-sort/ 桶排序 http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/ 其他排序：http://bubkoo.com/tags/algorithm/ 什么是算法以下是高德纳在他的著作《计算机程序设计艺术》里对算法的特征归纳 输入：一个算法必须有零个或以上输入量。 输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。 明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望，通常要求实际运行结果是确定的。 有限性：依据图灵的定义，一个算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定算法必须在有限个步骤内完成任务。 有效性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。 什么是数据结构就是数据的结构。 一般来说是这样的： 我们要解决一个跟数据相关的问题 分析这个问题，想出对应的数据结构 分析数据结构，想出算法 大分类 分治法：把一个问题分区成互相独立的多个部分分别求解的思路。这种求解思路带来的好处之一是便于进行并行计算。 动态规划法：当问题的整体最优解就是由局部最优解组成的时候，经常采用的一种方法。 贪婪算法：常见的近似求解思路。当问题的整体最优解不是（或无法证明是）由局部最优解组成，且对解的最优性没有要求的时候，可以采用的一种方法。 线性规划法：见词条。 简并法：把一个问题通过逻辑或数学推理，简化成与之等价或者近似的、相对简单的模型，进而求解的方法。 我们前端主要使用分治法——分而治之。 排序算法中国学生学不好排序算法主要是因为这些算法的名字是外国人取的 体育委员两两摸头法（冒泡排序） 体育老师一指禅法（选择排序） 起扑克牌法（插入排序） 强迫症收扑克牌法（基数排序） 快排 归并排序 堆排序 排序可视化：https://visualgo.net/bn/sorting 伪代码： 1234567891011121314151617181920212223242526272829303132333435a &lt;- &#123; &apos;0&apos;:4, &apos;1&apos;:6, &apos;2&apos;:3, &apos;3&apos;:2, &apos;4&apos;:1, &apos;length&apos;: 5&#125;轮数 = 1左手指向的下标 while(轮数 &lt; a[&apos;length&apos;]) 左手指向的下标 = 0 while(左手指向的下标 &lt;= a[&apos;length&apos;] - 1 - 轮数) if a[左手指向的下标] &lt; a[左手指向的下标+1] // 什么也不做 else // 交换左右的位置 t &lt;- a[左手指向的下标] a[左手指向的下标] &lt;- a[左手指向的下标+1] a[左手指向的下标+1] &lt;- t end 左手指向的下标 &lt;- 左手指向的下标+1 end 轮数 &lt;- 轮数 + 1endprint a/////////轮数 左手指向的下标最大值（从0开始）1 32 23 14 0 冒泡1234567891011121314151617function bubbleSort(array) &#123; var length = array.length, i, j, temp; for (i = length - 1; 0 &lt; i; i--) &#123; for (j = 0; j &lt; i; j++) &#123; if (array[j] &gt; array[j + 1]) &#123; temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; return array;&#125; 插入排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687function insertionSort(array) &#123; function swap(array, i, j) &#123; var temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; var length = array.length, i, j; for (i = 1; i &lt; length; i++) &#123; for (j = i; j &gt; 0; j--) &#123; if (array[j - 1] &gt; array[j]) &#123; swap(array, j - 1, j); &#125; else &#123; break; &#125; &#125; &#125; return array;&#125;②减少次数function insertionSort(array) &#123; var length = array.length, i, j, temp; for (i = 1; i &lt; length; i++) &#123; temp = array[i]; for (j = i; j &gt;= 0; j--) &#123; if (array[j - 1] &gt; temp) &#123; array[j] = array[j - 1]; &#125; else &#123; array[j] = temp; break; &#125; &#125; &#125; return array;&#125;③利用二分查找法实现的插入排序，二分查找排序：function insertionSort2(array) &#123; function binarySearch(array, start, end, temp) &#123; var middle; while (start &lt;= end) &#123; middle = Math.floor((start + end) / 2); if (array[middle] &lt; temp) &#123; if (temp &lt;= array[middle + 1]) &#123; return middle + 1; &#125; else &#123; start = middle + 1; &#125; &#125; else &#123; if (end === 0) &#123; return 0; &#125; else &#123; end = middle; &#125; &#125; &#125; &#125; function binarySort(array) &#123; var length = array.length, i, j, k, temp; for (i = 1; i &lt; length; i++) &#123; temp = array[i]; if (array[i - 1] &lt;= temp) &#123; k = i; &#125; else &#123; k = binarySearch(array, 0, i - 1, temp); for (j = i; j &gt; k; j--) &#123; array[j] = array[j - 1]; &#125; &#125; array[k] = temp; &#125; return array; &#125; return binarySort(array);&#125; 桶排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120桶排序 (Bucket sort)或所谓的箱排序的原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。排序过程：1. 假设待排序的一组数统一的分布在一个范围中，并将这一范围划分成几个子范围，也就是桶2. 将待排序的一组数，分档规入这些子桶，并将桶中的数据进行排序3. 将各个桶中的数据有序的合并起来实现：首先用最笨的方法，每一个桶只能放相同的数字，最大桶的数量为数组中的正数最大值加上负数最小值的绝对值。function bucketSort(array) &#123; var bucket = [], // 正数桶 negativeBucket = [], // 负数桶 result = [], l = array.length, i, j, k, abs; // 入桶 for (i = 0; i &lt; l; i++) &#123; if (array[i] &lt; 0) &#123; abs = Math.abs(array[i]); if (!negativeBucket[abs]) &#123; negativeBucket[abs] = []; &#125; negativeBucket[abs].push(array[i]); &#125; else &#123; if (!bucket[array[i]]) &#123; bucket[array[i]] = []; &#125; bucket[array[i]].push(array[i]); &#125; &#125; // 出桶 l = negativeBucket.length; for (i = l - 1; i &gt;= 0; i--) &#123; if (negativeBucket[i]) &#123; k = negativeBucket[i].length; for (j = 0; j &lt; k; j++) &#123; result.push(negativeBucket[i][j]); &#125; &#125; &#125; l = bucket.length; for (i = 0; i &lt; l; i++) &#123; if (bucket[i]) &#123; k = bucket[i].length; for (j = 0; j &lt; k; j++) &#123; result.push(bucket[i][j]); &#125; &#125; &#125; return result;&#125;下面这种方式就是文中举例分析的那样，每个桶存放一定范围的数字，用 step 参数来设置该范围，取 step 为 1 就退化成前一种实现方式。关键部位代码有注释，慢慢看，逻辑稍微有点复杂。/** @array 将要排序的数组** @step 划分桶的步长，比如 step = 5，表示每个桶存放的数字的范围是 5，像 -4&lt;sub&gt;1、0&lt;/sub&gt;5、6~11*/function bucketSort(array, step) &#123; var result = [], bucket = [], bucketCount, l = array.length, i, j, k, s, max = array[0], min = array[0], temp; for (i = 1; i &lt; l; i++) &#123; if (array[i] &gt; max) &#123; max = array[i] &#125; if (array[i] &lt; min) &#123; min = array[i]; &#125; &#125; min = min - 1; bucketCount = Math.ceil((max - min) / step); // 需要桶的数量 for (i = 0; i &lt; l; i++) &#123; temp = array[i]; for (j = 0; j &lt; bucketCount; j++) &#123; if (temp &gt; (min + step * j) &amp;&amp; temp &lt;= (min + step * (j + 1))) &#123; // 判断放入哪个桶 if (!bucket[j]) &#123; bucket[j] = []; &#125; // 通过插入排序将数字插入到桶中的合适位置 s = bucket[j].length; if (s &gt; 0) &#123; for (k = s - 1; k &gt;= 0; k--) &#123; if (bucket[j][k] &gt; temp) &#123; bucket[j][k + 1] = bucket[j][k]; &#125; else &#123; break; &#125; &#125; bucket[j][k + 1] = temp; &#125; else &#123; bucket[j].push(temp); &#125; &#125; &#125; &#125; for (i = 0; i &lt; bucketCount; i++) &#123; // 循环取出桶中数据 if (bucket[i]) &#123; k = bucket[i].length; for (j = 0; j &lt; k; j++) &#123; result.push(bucket[i][j]); &#125; &#125; &#125; return result;&#125;]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-简单了解一下]]></title>
    <url>%2F2018%2F04%2F25%2F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构哈希（Hash） 计数排序中的桶排序（复杂度O（n+max）），比快排快 桶排序与计数排序的区别 基数排序与计数排序的区别 队列（Queue） 先进先出 可用数组实现 举例： 排队 栈（Stack） 先进后出 可用数组实现 举例： 盗梦空间 链表（Linked List） 数组无法直接删除中间的一项，链表可以 用哈希（JS里面用对象表示哈希）实现链表 head、node概念 树（tree） 举例：层级结构、DOM 概念： 层数、深度、节点个数 二叉树 满二叉树 完全二叉树 完全二叉树和满二叉树可以用数组实现 其他树可以用哈希（对象）实现 操作： 增删改查 堆排序用到了tree 其他： B树、红黑数、AVL树 堆排序可视化: https://www.cs.usfca.edu/~galles/visualization/HeapSort.html堆排序JS代码完整讲解： http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/ 堆排序二叉树二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。 二叉树的每个结点至多只有二棵子树（不存在度大于 2 的结点），二叉树的子树有左右之分，次序不能颠倒。二叉树的第 i 层至多有 2^(i - 1) 个结点；深度为 k 的二叉树至多有 2^k - 1 个结点；对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则n0 = n2 + 1。 树和二叉树的三个主要差别： 树的结点个数至少为 1，而二叉树的结点个数可以为 0 树中结点的最大度数没有限制，而二叉树结点的最大度数为 2 树的结点无左、右之分，而二叉树的结点有左、右之分 二叉树又分为完全二叉树（complete binary tree）和满二叉树（full binary tree） 满二叉树：一棵深度为 k，且有 2k - 1 个节点称之为满二叉树 完全二叉树：深度为 k，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中序号为 1 至 n 的节点对应时，称之为完全二叉树 堆堆（二叉堆）可以视为一棵完全的二叉树，完全二叉树的一个“优秀”的性质是，除了最底层之外，每一层都是满的，这使得堆可以利用数组来表示（普通的一般的二叉树通常用链表作为基本容器表示），每一个结点对应数组中的一个元素。 对于给定的某个结点的下标 i，可以很容易的计算出这个结点的父结点、孩子结点的下标： Parent(i) = floor(i/2)，i 的父节点下标 Left(i) = 2i，i 的左子节点下标 Right(i) = 2i + 1，i 的右子节点下标 二叉堆一般分为两种：最大堆和最小堆。 最大堆： 最大堆中的最大元素值出现在根结点（堆顶） 堆中每个父节点的元素值都大于等于其孩子结点（如果存在） 最小堆： 最小堆中的最小元素值出现在根结点（堆顶） 堆中每个父节点的元素值都小于等于其孩子结点（如果存在） 堆排序原理 堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作： 最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点 创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆 堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 继续进行下面的讨论前，需要注意的一个问题是：数组都是 Zero-Based，这就意味着我们的堆数据结构模型要发生改变 相应的，几个计算公式也要作出相应调整： Parent(i) = floor((i-1)/2)，i 的父节点下标 Left(i) = 2i + 1，i 的左子节点下标 Right(i) = 2(i + 1)，i 的右子节点下标 最大堆调整（MAX‐HEAPIFY）的作用是保持最大堆的性质，是创建最大堆的核心子程序，作用过程如图所示： 由于一次调整后，堆仍然违反堆性质，所以需要递归的测试，使得整个堆都满足堆性质，用 JavaScript 可以表示如下： 123456789101112131415161718192021222324252627282930/** * 从 index 开始检查并保持最大堆性质 * * @array * * @index 检查的起始下标 * * @heapSize 堆大小 * **/function maxHeapify(array, index, heapSize) &#123; var iMax = index, iLeft = 2 * index + 1, iRight = 2 * (index + 1); if (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123; iMax = iLeft; &#125; if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123; iMax = iRight; &#125; if (iMax != index) &#123; swap(array, iMax, index); maxHeapify(array, iMax, heapSize); // 递归调整 &#125;&#125;function swap(array, i, j) &#123; var temp = array[i]; array[i] = array[j]; array[j] = temp;&#125; 通常来说，递归主要用在分治法中，而这里并不需要分治。而且递归调用需要压栈/清栈，和迭代相比，性能上有略微的劣势。当然，按照20/80法则，这是可以忽略的。但是如果你觉得用递归会让自己心里过不去的话，也可以用迭代，比如下面这样： 1234567891011121314151617181920212223242526272829303132333435/** * 从 index 开始检查并保持最大堆性质 * * @array * * @index 检查的起始下标 * * @heapSize 堆大小 * **/function maxHeapify(array, index, heapSize) &#123; var iMax, iLeft, iRight; while (true) &#123; iMax = index; iLeft = 2 * index + 1; iRight = 2 * (index + 1); if (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123; iMax = iLeft; &#125; if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123; iMax = iRight; &#125; if (iMax != index) &#123; swap(array, iMax, index); index = iMax; &#125; else &#123; break; &#125; &#125;&#125;function swap(array, i, j) &#123; var temp = array[i]; array[i] = array[j]; array[j] = temp;&#125; 创建最大堆（Build-Max-Heap）的作用是将一个数组改造成一个最大堆，接受数组和堆大小两个参数，Build-Max-Heap 将自下而上的调用 Max-Heapify 来改造数组，建立最大堆。因为 Max-Heapify 能够保证下标 i 的结点之后结点都满足最大堆的性质，所以自下而上的调用 Max-Heapify 能够在改造过程中保持这一性质。如果最大堆的数量元素是 n，那么 Build-Max-Heap 从 Parent(n) 开始，往上依次调用 Max-Heapify。流程如下： 12345678function buildMaxHeap(array, heapSize) &#123; var i, iParent = Math.floor((heapSize - 1) / 2); for (i = iParent; i &gt;= 0; i--) &#123; maxHeapify(array, i, heapSize); &#125;&#125; 堆排序（Heap-Sort）是堆排序的接口算法，Heap-Sort先调用Build-Max-Heap将数组改造为最大堆，然后将堆顶和堆底元素交换，之后将底部上升，最后重新调用Max-Heapify保持最大堆性质。由于堆顶元素必然是堆中最大的元素，所以一次操作之后，堆中存在的最大元素被分离出堆，重复n-1次之后，数组排列完毕。整个流程如下： 1234567function heapSort(array, heapSize) &#123; buildMaxHeap(array, heapSize); for (int i = heapSize - 1; i &gt; 0; i--) &#123; swap(array, 0, i); maxHeapify(array, 0, i); &#125; &#125; 最后，把上面的整理为完整的 javascript 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445function heapSort(array) &#123; function swap(array, i, j) &#123; var temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; function maxHeapify(array, index, heapSize) &#123; var iMax, iLeft, iRight; while (true) &#123; iMax = index; iLeft = 2 * index + 1; iRight = 2 * (index + 1); if (iLeft &lt; heapSize &amp;&amp; array[index] &lt; array[iLeft]) &#123; iMax = iLeft; &#125; if (iRight &lt; heapSize &amp;&amp; array[iMax] &lt; array[iRight]) &#123; iMax = iRight; &#125; if (iMax != index) &#123; swap(array, iMax, index); index = iMax; &#125; else &#123; break; &#125; &#125; &#125; function buildMaxHeap(array) &#123; var i, iParent = Math.floor(array.length / 2) - 1; for (i = iParent; i &gt;= 0; i--) &#123; maxHeapify(array, i, array.length); &#125; &#125; function sort(array) &#123; buildMaxHeap(array); for (var i = array.length - 1; i &gt; 0; i--) &#123; swap(array, 0, i); maxHeapify(array, 0, i); &#125; return array; &#125; return sort(array);&#125;]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行基础]]></title>
    <url>%2F2018%2F04%2F25%2F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[命令行 这是一篇命令行文章 查看当前完成路径123pwd~家目录，当前用户/根路径 查看当前目录下文件123ls 不包括隐藏文件ls -a 查看当前目录下所有文件ls -al 查看当前目录下所有文件的详细信息 切换目录1234cd /c/projectcd codecd ../csscd ~/Desktop 创建、删除文件123touch readme.mdrm redame.mdrm -rf node_modules 重命名1mv read.me REMEADME.md 创建文件夹1mkdir projects 文件路径1234根目录 cd/家目录 cd ~ pwd当前目录 cd books cd ./books上级目录 cd .. cd ../css 编辑器 编辑模式命令模式 vim a.md初始化进入编辑器命令行模式 i进入编辑模式 键盘左上角esc进入命令行模式 :wq保存退出 :q!不保存强制退出 cat 安装服务器12npm install -g http-serverhttp-server 文件权限12chmod 777 index.htmlchown -R git:git ruoyu]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS里的数据]]></title>
    <url>%2F2018%2F04%2F24%2FJavaScript%2FJS%E9%87%8C%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[JS里的数据js的历史数据类型七种数据类型：number string boolean symbol undefined null object注意没有 array 类型也没有 function 类型 number 整数和小数： 1 1.1 .1 科学计数法：1.23e2 二进制： 0b11 八进制： 011 0o11(ES5) 十六进制： 0x11 string 空字符串： ‘’ 多行字符串： 123456var s = &apos;12345&apos; + &apos;6789&apos; //无回车符号或var s = `12345667890 // 包含回车符` boolean 乔治·布尔乔治·布尔是英格兰数学家和哲学家、数理逻辑学先驱。由于其在符号逻辑运算中的特殊贡献，很多计算机语言中将逻辑运算称为布尔运算，将其结果称为布尔值。1864年，布尔冒着大雨步行两英里走到讲台，身着打湿的衣服为学生们授课。不久后，他就病倒了，得了重度感冒还发高烧。其妻错误地相信疾病需要用致病因子施救，因为布尔是淋雨水而感冒的，妻子于是用桶子装水淋到他身上。结果湿气进一步加剧了他的病情。1864年，12月8日，布尔死于肺部积水。上面资料的来源是维基百科，请自行选择是否相信。 boolean 的取值只有两个值：true 和 falsea &amp;&amp; b 在 a 和 b 都为 true 时，取值为 true；否则为 falsea || b 在 a 和 b 都为 false 时，取值为 false；否则为 true symbol 方应杭：JS 中的 Symbol 是什么？ undefined 和 null都表示没有值，至于 JS 为什么有两个表示「没有值」的东西，可以从 JS 之父的 twitter 中知道当时他也挺纠结的：https://twitter.com/BrendanEich/status/333008305461006336 规范）如果一个变量没有被赋值，那么这个变量的值就是 undefiend （习俗）如果你想表示一个还没赋值的对象，就用 null。如果你想表示一个还没赋值的字符串/数字/布尔/symbol，就用 undefined（但是实际上你直接 var xxx 一下就行了，不用写 var xxx = undefined） object object 就是上面几种基本类型（无序地）组合在一起 object 里面可以有 object 123456var person = &#123; name: &apos;Frank&apos;, &apos;child&apos;: &#123; name: &apos;Jack&apos; &#125;, // 最后这个逗号可有可无&#125; - object 的 key 一律是字符串，不存在其他类型的 key - object[&apos;&apos;] 是合法的 - object[&apos;key&apos;] 可以写作 object.key - 注意 object.key 与 object[key] 不同 - delete object[&apos;key&apos;] - &apos;key&apos; in object typeof 操作符 xxx 的类型 string number boolean symbol undefined null object function typeofxxx ‘string’ ‘number’ ‘boolean’ ‘symbol’ ‘undefined’ ‘object’ ‘object’ ‘function’ 注意：function不是类型]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客教程.md]]></title>
    <url>%2F2018%2F04%2F22%2FHexo%2FHexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B-md%2F</url>
    <content type="text"><![CDATA[使用Hexo + GitHub搭建博客搭建步骤： 进入一个安全的目录，比如 cd ~/Desktop 或者 cd ~/Documents，别在根目录 / 瞎搞。以后所有的教程第一步都是「进入一个安全的目录，别在根目录瞎搞」，只有 ~ 里面的目录是你能碰的! 在 GitHub 上新建一个空 repo，repo 名称是「你的用户名.github.io」（注意个用户名是你的GitHub用户名，不是你的电脑用户名） 安装Hexo， npm install -g hexo-cli hexo init myBlog cd myBlog npm i hexo new 开博大吉，你会看到一个md文件的路径(Windows 的路径中的 \ 需要变成 / 才行哦) start xxxxxxxxxxxxxxxxxxx.md，编辑这个 md 文件，内容自己想（Ubuntu 系统用 xdg-open xxxxxxxxxxxxxxxxxxx.md 命令） start _config.yml，编辑网站配置 把第 6 行的 title 改成你想要的名字 把第 9 行的 author 改成你的大名 把最后一行的 type 改成 type: git 在最后一行后面新增一行，左边与 type 平齐，加上一行 repo: 仓库地址 （请将仓库地址改为「你的用户名.github.io」对应的仓库地址，仓库地址以 git@github.com: 开头你知道吧？不知道？不知道的话现在你知道了） 第 4 步的 repo: 后面有个空格，注意！！！ npm install hexo-deployer-git --save，安装 git 部署插件 hexo deploy 进入「你的用户名.github.io」对应的 repo，打开 GitHub Pages 功能，如果已经打开了，就直接点击预览链接 你现在应该看到了你的博客！ 第二篇博客 hexo new 第二篇博客 复制显示的路径，使用 start 路径 来编辑它 hexo generate hexo deploy 去看你的博客，应该能看到第二篇博客了 更换主题 https://github.com/hexojs/hexo/wiki/Themes 上面有主题合集 随便找一个主题，进入主题的 GitHub 首页，比如我找的是 https://github.com/iissnan/hexo-theme-next 复制它的 SSH 地址或 HTTPS 地址，假设地址为 git@github.com:iissnan/hexo-theme-next.git cd themes git clone git@github.com:iissnan/hexo-theme-next.git cd .. 将 _config.yml 的第 75 行改为 theme: hexo-theme-next，保存 hexo generate hexo deploy 等一分钟，然后刷新你的博客页面，你会看到一个新的外观。如果不喜欢这个主题，就回到第 1 步，重选一个主题。 上传源代码注意「你的用户名.github.io」上保存的只是你的博客，并没有保存「生成博客的程序代码」，你需要再创建一个名为 blog-generator 的空仓库，用来保存 myBlog 里面的「生成博客的程序代码」。 在 GitHub 创建 blog-generator 空仓库 按照截图中的命令执行即可，记住，别 TMD 用 HTTPS 地址。 这样一来，你的博客发布在了「你的用户名.github.io」而你的「生成博客的程序代码」发布在了 blog-generator。所有数据万无一失，你就不会因为误删 myBlog 目录而痛哭了。 以后每次 hexo deploy 完之后，博客就会更新；然后你还要要 add / commit /push 一下「生成博客的程序代码」，以防万一。 这个 blog-generator 就是用来生成博客的程序，而「你的用户名.github.io」仓库就是你的博客页面。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sh任务]]></title>
    <url>%2F2018%2F03%2F12%2F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2Fsh%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[代码如下12345678910111213141516if [ -d $1 ]; then echo ‘$! 已经存在’ exitelse mkdir $1 cd $1 mkdir css js touch index.html css/style.css js/main.js echo \&lt;\!DOCTYPE\&gt; &gt;&gt; index.html echo \&lt;title\&gt;hello\&lt;/title\&gt; &gt;&gt; index.html echo \&lt;h1\&gt;Hi\&lt;/h1\&gt; &gt;&gt; index.html echo h1\&#123;color\: red\;\&#125; &gt;&gt; css/style.css echo var string \= \”Hello World\” &gt;&gt; js/main.js echo alert\(string\) &gt;&gt; js/main.jsexitfi]]></content>
      <categories>
        <category>编程基础</category>
      </categories>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三篇博客]]></title>
    <url>%2F2018%2F03%2F12%2Funcategorized%2F%E7%AC%AC%E4%B8%89%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hi]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F12%2FHexo%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
